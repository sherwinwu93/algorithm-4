# 第2章 排序
整理数据的第一步通常就是进行排序
- 对排序算法的分析有助于全面理解比较算法性能的方法
- 类似的解决其他问题
- 排序常常是解决其他问题第一步
## 2.1 初级排序算法
学习两种初级算法和一个变体
1. 熟悉术语和技巧
2. 初级算法比复杂算法有时更有效
3. 有助于改进复杂算法的效率
### 2.1.1 游戏规则
元素: 对象  
主键: 通过Comparable  
#### 2.1.1.1 验证
#### 2.1.1.2 运行时间
排序成本模型: 比较和交换的数量,而不交换元素的算法,比较访问数组的次数
#### 2.1.1.3 额外的内存使用
原地排序算法:  
其他排序算法:  
#### 2.1.1.4 数据类型
相关的工具,研究选择~插入~希尔~归并~快速~堆排序,2.5实际应用
### 2.1.2 选择排序
选择排序: 不断选择剩余元素之中的最小者  
性能: 交换的总次数是N,取决于比较的次数  
特点: 
1. 运行时间和输入无关
2. 数据移动是最少的
###### 命题A. 对于长度为N的数组,选择排序需要大约N^2/2和N次交换
证明: 用NxN的表格表示排序的轨迹来证明
### 2.1.3 插入排序
插入排序: 插入有序的牌时,该牌的右边右移一位  
时间: 所需时间取决于输入的初始顺序  
典型的部分有序的数组: 当倒置数量很少时,插入排序可能比任何算法要快
- 数据中每个元素距离最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确
###### 命题B. 最坏情况需要~N^2/2次比较和~N^2/2次交换,  最好情况需要N-1次比较和0次交换
证明: NxN的轨迹表
###### 命题C. 插入排序的交换操作和倒置数量相同,需要的比较次数>=倒置数量,小于等于倒置数量+数组大小-1
证明: 每次交换都改变了顺序颠倒元素的位置,减少了一对倒置,倒置数量为0时,排序就完成了.每次交换对应一次比较,对于每个i可能需要多一次
额外的比较(未到达数组的左端,代码中的j > 0 && less(a[j], a[j - 1]).  
提升性能: 内循环中较大的元素向右移动,而不总是交换
### 2.1.4 排序算法的可视化
棒状图
### 2.1.5 比较两种排序算法
选择排序和插入排序哪种更快  
科学方法
- 实现并调试它们(算法2.1,2.1)
- 分析它们的基本性质(命题ABC)
- 对它们的相对性能做出猜想(性质D)
- 用实验验证我们的猜想(SortCompare类)  
实现算法之后,下一步确定适当的输入模型.重复主键,需要更加复杂的模型  
###### 性质D. 对于随机排序无重复主键的数组,插入和选择时间是平方级别的,两者之比是一个较小的常数
例证:通过SortCompare检测  
用实际数据验证我们的猜想  
### 2.1.6 希尔排序
希尔排序: 使数组间隔为h的元素都有序(h有序数组).进行排序时,h很大,就能将元素移动到很远的地方,为更小的h有序创造方便.当h降低到1时,
我们就将数组排序好了.  
算法2.3: 序列1/2(3^k - 1),从N/3递减到1,递增序列  
希尔排序更高效的原因是因为权衡了子数组的规模和有序性  
如何选择递增序列?算法性质不但取决于h,还取决h之间的性质  
Insertion->Shell: 通过提升速度解决原本无法解决的问题是研究算法的设计和性能的主要原因  
性能: N^(3/2)
###### 性质E.递增序列1,4,13,40,121,364...的希尔排序比较次数不会超出N的若干倍乘以递增序列的长度
例证:记录算法2.3比较次数并除以序列长度.比较次数约为N^(1/5).实验证明!  
适用范围: 中等大小数组(代码量小,不需要额外内存空间),硬件或者嵌入式系统的代码
## 2.2 归并排序
归并: 将两个有序的数组归并成一个更大的有序数组  
归并排序: 递归地分成两半分别排序,然后将结果归并起来  
- 时间: NlogN
- 额外空间: N
### 2.2.1 原地归并的抽象方法
原地递归的办法: 先将前半部分排序,再将后半部分排序,数组移动元素不需要额外的空间
原地归并:
1. 数组复制到辅助数组
2. 数组左边,右边归并分为三种情况
2.1 左边用尽,取右边
2.2 右边用尽,取左边
2.3 右边小于左边,取右边
2.4 左边小于等于右边,取左边  
### 2.2.2 自顶向下的归并排序
分治思想的最典型的例子
排序调用轨迹
s0-15
    s0-7
        s0-3
            s0-1
                m0-1
            s2-3
                m2-3
            m0-3
        s4-7
            s4-5
                m4-5
            s6-7
                m6-7
            m4-7
    s8-15
        s8-11
            s8-9
                m8-9
            s10-11
                m10-11
            m8-11
        s12-15
            s12-13
                m12-13
            s14-15
                m14-15
            m12-15
        m8-15
    m0-15
###### 命题F.对任意长度N数组,归并排序需要1/2NlgN到NlgN次比较
证明: C(N)为N的比较次数, C(0)=C(1)=0,由递归的sort(),的出比较次数的上限
上限
C(N)<=C(ceil(N/2)) + C(floor(N/2)) + N
下限
C(N)>=C(ceil(N/2)) + C(floor(N/2)) + floor(N/2)
因为ceil(N/2)=floor(N/2)=2^(n-1)
C(2^n)=2C(2^(n-1)) + 2^n
###### 命题G. 对于长度为N的任意数组,自顶向下的归并排序最多需要访问数组6NlgN次
证明: 每次归并最多需要访问数组6N次,2N复制,2N将排序好的移动回去,2N次比较

归并排序可以处理数百万甚至更大规模的数组,缺点是额外空间与N成正比

#### 2.2.2.1 对下规模子数组使用插入排序
可以将运行时间缩短10%~15%
#### 2.2.2.2 测试数组是否已经有序
如果a[mid] 小于等于a[mid+1], 认为数组已经有序了,导致任意有序的子数组算法运行时间是线性的
#### 2.2.2.3 不将元素复制到辅助数组
调用两种排序方法: 一种将数据从输入数组排序到辅助数组,一种将辅助数组排序到输入数组  
不要对算法初始实现性能盖棺定论.  
研究新问题: 最好先实现一个最简单的程序,成为瓶尽再改进它.实现运行时间缩短常数因子可能并不值得.需要实验检验  
### 2.2.3 自底向上的归并排序
分治思想: 将大问题分割成小问题分别解决,再用所有小问题的答案解决整个大问题  
###### 命题H,长度为N的任意数组,自底向上需要1/2NlgN至NlgN次比较,最多访问数组6NlgN次
证明: 处理数组的遍数是ceil(lgN), 每一遍访问数组6N次,比较次数N/2和N之间  
自底向上的归并排序适合用链表组织的数组.  
当能用一种方法解决问题时,都应该试试另一种
### 2.2.4 排序算法的复杂度
归并排序是证明计算复杂度领域的一个重要结论的基础, 计算复杂性能帮助我们理解排序自身固有的难易程度  
研究复杂度:  
1. 建立计算模型.
    对于排序,研究对象是基于比较的算法,由数组的逐渐决定
###### 命题I. 没有任何基于比较的算法能使用少于lg(N!)~NlgN次比较将长度为N的数组排序
证明: 假设没有重复主键(因为任何排序算法必须能处理这种情况).  
二叉树:
    节点: 1:2
    左分支: 满足1<2的子树
    右分支: 不满足1<2的子数
    叶子: 2 1 0 (已经排序好的数组)
高度: h
完全树: 叶子=2^h
---------------- 基于比较的排序模型
任意基于比较的排序算法都对应高h的比较树  
N!(排序组合)<=叶子节点数量<=2^h  
h就是最坏情况下的比较次数,两边同时取对数,得出h>=lg(N!)~NlgN  
这就是设计排序算法的最佳效果  

命题H说明最坏情况比较次数为~NlgN(上限), 命题I说明最好情况为~NlgN(下限).

###### 命题J.归并排序是一种渐进最优的基于比较排序的算法

上限: 为性能保证提供了空间  
下限: 避免不可能的性能改进投入资源  
但是归并排序的最优性能并没有结束  
- 空间复杂度不是最优的
- 实践中不一定遇到最坏情况
- 除了比较,算法其他操作也可能很重要
- 不进行比较也能将某些数据排序
###### 答疑
- 希尔排序很好用

