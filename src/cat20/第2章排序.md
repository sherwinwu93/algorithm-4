# 第2章 排序
整理数据的第一步通常就是进行排序
- 对排序算法的分析有助于全面理解比较算法性能的方法
- 类似的解决其他问题
- 排序常常是解决其他问题第一步
## 2.1 初级排序算法
学习两种初级算法和一个变体
1. 熟悉术语和技巧
2. 初级算法比复杂算法有时更有效
3. 有助于改进复杂算法的效率
### 2.1.1 游戏规则
元素: 对象  
主键: 通过Comparable  
#### 2.1.1.1 验证
#### 2.1.1.2 运行时间
排序成本模型: 比较和交换的数量,而不交换元素的算法,比较访问数组的次数
#### 2.1.1.3 额外的内存使用
原地排序算法:  
其他排序算法:  
#### 2.1.1.4 数据类型
相关的工具,研究选择~插入~希尔~归并~快速~堆排序,2.5实际应用
### 2.1.2 选择排序
选择排序: 不断选择剩余元素之中的最小者  
性能: 交换的总次数是N,取决于比较的次数  
特点: 
1. 运行时间和输入无关
2. 数据移动是最少的
###### 命题A. 对于长度为N的数组,选择排序需要大约N^2/2和N次交换
证明: 用NxN的表格表示排序的轨迹来证明
### 2.1.3 插入排序
插入排序: 插入有序的牌时,该牌的右边右移一位  
时间: 所需时间取决于输入的初始顺序  
典型的部分有序的数组: 当倒置数量很少时,插入排序可能比任何算法要快
- 数据中每个元素距离最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确
###### 命题B. 最坏情况需要~N^2/2次比较和~N^2/2次交换,  最好情况需要N-1次比较和0次交换
证明: NxN的轨迹表
###### 命题C. 插入排序的交换操作和倒置数量相同,需要的比较次数>=倒置数量,小于等于倒置数量+数组大小-1
证明: 每次交换都改变了顺序颠倒元素的位置,减少了一对倒置,倒置数量为0时,排序就完成了.每次交换对应一次比较,对于每个i可能需要多一次
额外的比较(未到达数组的左端,代码中的j > 0 && less(a[j], a[j - 1]).  
提升性能: 内循环中较大的元素向右移动,而不总是交换
### 2.1.4 排序算法的可视化
棒状图
### 2.1.5 比较两种排序算法
选择排序和插入排序哪种更快  
科学方法
- 实现并调试它们(算法2.1,2.1)
- 分析它们的基本性质(命题ABC)
- 对它们的相对性能做出猜想(性质D)
- 用实验验证我们的猜想(SortCompare类)  
实现算法之后,下一步确定适当的输入模型.重复主键,需要更加复杂的模型  
###### 性质D. 对于随机排序无重复主键的数组,插入和选择时间是平方级别的,两者之比是一个较小的常数
例证:通过SortCompare检测  
用实际数据验证我们的猜想  
### 2.1.6 希尔排序
希尔排序: 使数组间隔为h的元素都有序(h有序数组).进行排序时,h很大,就能将元素移动到很远的地方,为更小的h有序创造方便.当h降低到1时,
我们就将数组排序好了.  
算法2.3: 序列1/2(3^k - 1),从N/3递减到1,递增序列  
希尔排序更高效的原因是因为权衡了子数组的规模和有序性  
如何选择递增序列?算法性质不但取决于h,还取决h之间的性质  
Insertion->Shell: 通过提升速度解决原本无法解决的问题是研究算法的设计和性能的主要原因  
性能: N^(3/2)
###### 性质E.递增序列1,4,13,40,121,364...的希尔排序比较次数不会超出N的若干倍乘以递增序列的长度
例证:记录算法2.3比较次数并除以序列长度.比较次数约为N^(1/5).实验证明!  
适用范围: 中等大小数组(代码量小,不需要额外内存空间),硬件或者嵌入式系统的代码
