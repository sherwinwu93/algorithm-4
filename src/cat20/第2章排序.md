# 第2章 排序
整理数据的第一步通常就是进行排序
- 对排序算法的分析有助于全面理解比较算法性能的方法
- 类似的解决其他问题
- 排序常常是解决其他问题第一步
## 2.1 初级排序算法
学习两种初级算法和一个变体
1. 熟悉术语和技巧
2. 初级算法比复杂算法有时更有效
3. 有助于改进复杂算法的效率
### 2.1.1 游戏规则
元素: 对象  
主键: 通过Comparable  
#### 2.1.1.1 验证
#### 2.1.1.2 运行时间
排序成本模型: 比较和交换的数量,而不交换元素的算法,比较访问数组的次数
#### 2.1.1.3 额外的内存使用
原地排序算法:  
其他排序算法:  
#### 2.1.1.4 数据类型
相关的工具,研究选择~插入~希尔~归并~快速~堆排序,2.5实际应用
### 2.1.2 选择排序
选择排序: 不断选择剩余元素之中的最小者  
性能: 交换的总次数是N,取决于比较的次数  
特点: 
1. 运行时间和输入无关
2. 数据移动是最少的
###### 命题A. 对于长度为N的数组,选择排序需要大约N^2/2和N次交换
证明: 用NxN的表格表示排序的轨迹来证明
### 2.1.3 插入排序
插入排序: 插入有序的牌时,该牌的右边右移一位  
时间: 所需时间取决于输入的初始顺序  
典型的部分有序的数组: 当倒置数量很少时,插入排序可能比任何算法要快
- 数据中每个元素距离最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确
###### 命题B. 最坏情况需要~N^2/2次比较和~N^2/2次交换,  最好情况需要N-1次比较和0次交换
证明: NxN的轨迹表
###### 命题C. 插入排序的交换操作和倒置数量相同,需要的比较次数>=倒置数量,小于等于倒置数量+数组大小-1
证明: 每次交换都改变了顺序颠倒元素的位置,减少了一对倒置,倒置数量为0时,排序就完成了.每次交换对应一次比较,对于每个i可能需要多一次
额外的比较(未到达数组的左端,代码中的j > 0 && less(a[j], a[j - 1]).  
提升性能: 内循环中较大的元素向右移动,而不总是交换
### 2.1.4 排序算法的可视化
棒状图
### 2.1.5 比较两种排序算法
选择排序和插入排序哪种更快  
科学方法
- 实现并调试它们(算法2.1,2.1)
- 分析它们的基本性质(命题ABC)
- 对它们的相对性能做出猜想(性质D)
- 用实验验证我们的猜想(SortCompare类)  
实现算法之后,下一步确定适当的输入模型.重复主键,需要更加复杂的模型  
###### 性质D. 对于随机排序无重复主键的数组,插入和选择时间是平方级别的,两者之比是一个较小的常数
例证:通过SortCompare检测  
用实际数据验证我们的猜想  
### 2.1.6 希尔排序
希尔排序: 使数组间隔为h的元素都有序(h有序数组).进行排序时,h很大,就能将元素移动到很远的地方,为更小的h有序创造方便.当h降低到1时,
我们就将数组排序好了.  
算法2.3: 序列1/2(3^k - 1),从N/3递减到1,递增序列  
希尔排序更高效的原因是因为权衡了子数组的规模和有序性  
如何选择递增序列?算法性质不但取决于h,还取决h之间的性质  
Insertion->Shell: 通过提升速度解决原本无法解决的问题是研究算法的设计和性能的主要原因  
性能: N^(3/2)
###### 性质E.递增序列1,4,13,40,121,364...的希尔排序比较次数不会超出N的若干倍乘以递增序列的长度
例证:记录算法2.3比较次数并除以序列长度.比较次数约为N^(1/5).实验证明!  
适用范围: 中等大小数组(代码量小,不需要额外内存空间),硬件或者嵌入式系统的代码
## 2.2 归并排序
归并: 将两个有序的数组归并成一个更大的有序数组  
归并排序: 递归地分成两半分别排序,然后将结果归并起来  
- 时间: NlogN
- 额外空间: N
### 2.2.1 原地归并的抽象方法
原地递归的办法: 先将前半部分排序,再将后半部分排序,数组移动元素不需要额外的空间
原地归并:
1. 数组复制到辅助数组
2. 数组左边,右边归并分为三种情况
2.1 左边用尽,取右边
2.2 右边用尽,取左边
2.3 右边小于左边,取右边
2.4 左边小于等于右边,取左边  
### 2.2.2 自顶向下的归并排序
分治思想的最典型的例子
排序调用轨迹
s0-15
    s0-7
        s0-3
            s0-1
                m0-1
            s2-3
                m2-3
            m0-3
        s4-7
            s4-5
                m4-5
            s6-7
                m6-7
            m4-7
    s8-15
        s8-11
            s8-9
                m8-9
            s10-11
                m10-11
            m8-11
        s12-15
            s12-13
                m12-13
            s14-15
                m14-15
            m12-15
        m8-15
    m0-15
###### 命题F.对任意长度N数组,归并排序需要1/2NlgN到NlgN次比较
证明: C(N)为N的比较次数, C(0)=C(1)=0,由递归的sort(),的出比较次数的上限
上限
C(N)<=C(ceil(N/2)) + C(floor(N/2)) + N
下限
C(N)>=C(ceil(N/2)) + C(floor(N/2)) + floor(N/2)
因为ceil(N/2)=floor(N/2)=2^(n-1)
C(2^n)=2C(2^(n-1)) + 2^n
###### 命题G. 对于长度为N的任意数组,自顶向下的归并排序最多需要访问数组6NlgN次
证明: 每次归并最多需要访问数组6N次,2N复制,2N将排序好的移动回去,2N次比较

归并排序可以处理数百万甚至更大规模的数组,缺点是额外空间与N成正比

#### 2.2.2.1 对下规模子数组使用插入排序
可以将运行时间缩短10%~15%
#### 2.2.2.2 测试数组是否已经有序
如果a[mid] 小于等于a[mid+1], 认为数组已经有序了,导致任意有序的子数组算法运行时间是线性的
#### 2.2.2.3 不将元素复制到辅助数组
调用两种排序方法: 一种将数据从输入数组排序到辅助数组,一种将辅助数组排序到输入数组  
不要对算法初始实现性能盖棺定论.  
研究新问题: 最好先实现一个最简单的程序,成为瓶尽再改进它.实现运行时间缩短常数因子可能并不值得.需要实验检验  
### 2.2.3 自底向上的归并排序
分治思想: 将大问题分割成小问题分别解决,再用所有小问题的答案解决整个大问题  
###### 命题H,长度为N的任意数组,自底向上需要1/2NlgN至NlgN次比较,最多访问数组6NlgN次
证明: 处理数组的遍数是ceil(lgN), 每一遍访问数组6N次,比较次数N/2和N之间  
自底向上的归并排序适合用链表组织的数组.  
当能用一种方法解决问题时,都应该试试另一种
### 2.2.4 排序算法的复杂度
归并排序是证明计算复杂度领域的一个重要结论的基础, 计算复杂性能帮助我们理解排序自身固有的难易程度  
研究复杂度:  
1. 建立计算模型.
    对于排序,研究对象是基于比较的算法,由数组的逐渐决定
###### 命题I. 没有任何基于比较的算法能使用少于lg(N!)~NlgN次比较将长度为N的数组排序
证明: 假设没有重复主键(因为任何排序算法必须能处理这种情况).  
二叉树:
    节点: 1:2
    左分支: 满足1<2的子树
    右分支: 不满足1<2的子数
    叶子: 2 1 0 (已经排序好的数组)
高度: h
完全树: 叶子=2^h
---------------- 基于比较的排序模型
任意基于比较的排序算法都对应高h的比较树  
N!(排序组合)<=叶子节点数量<=2^h  
h就是最坏情况下的比较次数,两边同时取对数,得出h>=lg(N!)~NlgN  
这就是设计排序算法的最佳效果  

命题H说明最坏情况比较次数为~NlgN(上限), 命题I说明最好情况为~NlgN(下限).

###### 命题J.归并排序是一种渐进最优的基于比较排序的算法

上限: 为性能保证提供了空间  
下限: 避免不可能的性能改进投入资源  
但是归并排序的最优性能并没有结束  
- 空间复杂度不是最优的
- 实践中不一定遇到最坏情况
- 除了比较,算法其他操作也可能很重要
- 不进行比较也能将某些数据排序
###### 答疑
- 希尔排序很好用

## 2.3 快速排序
快速排序的应用最广泛:
    - 原地排序
    - 快
    缺点:容易弄错,产生低劣的性能  
### 2.3.1 基本算法
归并排序: 递归调用在处理整个数组之前  
快排: 递归调用发生在处理整个数组之后  
快排的大致过程:  
    - 输入
    - 打乱
    - 切分
    - 左半部分排序
    - 右半部分排序
    - 结果
切分使得数组满足三个条件:  
    - a[j]已经排定 
    - a[lo]~a[j-1]都不大于a[j]
    - a[j+1]~a[hi]都不小于a[j];  
证明排序有效:  
如果左子数组和右子数组都是有序的,那么由左子数组~切分元素和右子数组组成的结果也一定是有序的  
#### 2.3.1.1 原地切分
如果使用辅助数组狠容易进行切换,但是将切分的数组复制回去的开销很大.  
增加了额外的空间,降低了性能  
低级一点,再切分中创建数组性能更低  
#### 2.3.1.2 别越界
如果切分元素是数组中最小或最大的元素,小心别让扫描指针跑出数组的边界. j==lo是冗余的,因为a[lo]不可能小于自身,右端也有相同的情况可
以去掉.  
见练习题    
#### 2.3.1.3 保持随机性
保持随机性的另一种方法是在切分中随机选择一个切分元素  
不选择lo,而是选择一个lo...hi的随机数,与lo进行交换 
#### 2.3.1.4 终止循环
保证循环结束需要格外小心.一个常见的错误是没有考虑到数组中可能包含和切分元素相同的元素  
判断指针停止,左边是<,右边是>.如果左边指针的元素是=,右边也是=,那么会发生左右交换但是情况并没有改变,会无限循环  
#### 2.3.1.5 处理切分元素值有重复的情况
左侧扫描遇到大于等于切分元素值停下,右侧扫描遇到小于等于切分元素时停下  
可能会不必要地将一些等值元素交换,但是能够避免算法的运行时间变为平方级别  
??????  
#### 2.3.1.6 终止递归
不能保证将切分元素放入正确的位置,从而导致程序在切分元素正好是子数组的最大或最小元素时,陷入了无限的递归  
sort(a, 0, 7)  
    最大元素的情况:  
    j = 7
    sort(a, 0, 7) 
    sort(a, 8, 7)
    ...
    无限递归  
    最小元素的情况
    j =0
    sort(a, 0, -1);
    sort(a, 0, 7);
    也是无限递归  
### 2.3.2 性能特点
性能的证明:数学分析,大量的经验证实了这些分析  
    切分方法的内循环非常短小  
        归并和希尔比快排慢, 因为在内循环移动数据   
    比较次数少:
        平均而言切分落在数组中间  
        满足分治公式: C(N) = 2C(N/2) +N  
潜在的缺点: 第一次切分从最小的元素切分,第二次切分从第二小的元素切分...每次调用只会移除一个元素  
###### 命题K.
将长度为N的无重复数组排序,快速排序平均需要~2NlnN次比较(以及1/6交换)  
###### 命题L.
快排最多需要N^2/2次比较,但随机打乱数组能够预防这种情况   
N+(N-1) + (N-2) + ... + 2 + 1 = (N + 1)N/2  

### 2.3.3 算法改进  
你需要通过实验来确定改进的效果并为实现选择最佳的参数.性能一般能提升20~30%  
#### 2.3.3.1 切换到插入排序
- 对于小数组,快速排序比插入排序慢
- 因为递归,快排的sort()方法在小数组中也会调用自己  
#### 2.3.3.2 三取样切分
使用子数组的一小部分元素的中位数来切分数组.这样切分效果更好,但代价需要计算中位数.取样大小设为3效果最好,还可以将取样元素放在数组
末尾作为"哨兵"来去掉切分的数组边界测试  
#### 2.3.3.3 熵最优的排序  
荷兰国旗问题:  
    - 从左到右遍历数组一次  
    - 维护指针lt使得a[lo...lt-1]的元素都小于v
    - 指针gt,a[gt+1..hi]都大于v
    - 指针i使a[lt...i-1]都等于v,a[i..gt]的元素都还未确定  
三向切分:
    - a[i]<v,将a[lt]和a[i]交换,将lt和i加一
    - a[i]>v,将a[gt]和a[i]交换,将gt减一
    - a[i]等于v,将i加一  

从三向切分的quick可是轨迹可以看出,主键值数量的N倍是运行时间的保守的上界(实际可能更低)  
分析:
    包含k个不同值的N个主键,p(i)=f(i)/N,i是某个主键值,p是概率,f(i)为次数.  
    香农信息量:H=-(p1lgp1+p2lgp2..+pklgpk)  
    根据信息得出比较次数的上下界  
###### 命题M. 不存在任何基于比较的排序算法能够保证在NH-N次比较之内将N个元素排序  
###### 命题N. 对于大小为N的数组,三向切分的快排需要~(2ln2)NH次比较  

当所有主键均不重复时,H=lgN,与命题I和命题K是一致的.存在重复主键,性能会比归并排序好的多,这两个性质一起说明了三向切分是信息量最优  

t(三向切分) = kNH (k是常数,H是香农信息量,N)  
    当数组有大量重复元素时,H相对N足够小.三向切分从原来的NlnN变为N级别  
                        H最大时是lnN,等于普通的快速排序NlnN  
    三向切分是排序库函数的最佳算法选择  
    
关于快排的知识点:  
    1. 切分轨迹  
    2. 快排轨迹
    3. 最大元素最多交换N/2
    4. 比较次数的最坏情况是总得到空数组
    5. 用Quick3way处理重复值
    6. 比较次数期望值是2NlnN
    7. 0,1,2子数组的数量分别是N/3,N/3,N/6
    8. 处理全部重复的比较次数为N^2/2
    9. 处理两种重复元素,和三种重复元素的轨迹
    10. 到N^2的概率极低
    11. 遇到重复元素要停下来,不然要到平方级别
    12. Quick3way的轨迹
    13. 递归深度
    14. 比较次数2NlnN
    
#### 2.4.4.6 索引优先队列
用例如何引用已经进入优先队列的元素  
    1. 给元素索引
    2. 建立平行数组
```java 
// 把它看作数组
public interface IndexMinPQ<Item extends Comparable<Item>> {
    
    IndexMinPQ(int maxN);
    
    // = 增加k,并pq[k] = item
    void insert(int k, Item item);
    // = pq[k] = item
    void change(int k, Item item);
    // 是否包含k
    boolean contains(int k);
    // pq[k] = null
    void delete(int k);
    Item min();
    int minIndex();
    // 删除最小,并返回索引
    int delMin();
    boolean isEmpty();
    int size();
}
```

#### 2.4.4.7 索引优先队列用例
多项归并问题:
    定义: 多个有序的输入流合并成一个有序的输入流  
    例子: 多人同时存钱,银行的总资产;多个音乐列表;合并多个list  
    类型: 数组~索引优先队列  
    
### 2.4.5 堆排序
优先队列转排序,将元素都放入最小优先队列中,依次删除最小元素,这样就排好序了.
    无序数组:相当于选择排序  
    堆: 全新的堆排序  
堆排序有两个阶段:
    堆的构造阶段:重新放入一堆中  
    堆的下沉排序阶段:按顺序递减得出排序结果

#### 2.4.5.1 堆的构造
堆的构造:
    1. 从左到右用swim,NlgN
    2. 从右到左用sink,可以跳过一半为1的子堆.最后最大元素在1的位置,而不是最小元素C(N)<2N,E(N)<N  
        减少了的该变量,确实非常聪明

#### 2.4.5.2 下沉排序
先删除最大元素,再把这个元素放到堆减少后空余出来的位置.与选择排序类似,但选择是N,堆则是lgN  

#### 2.4.5.3 先下沉后上浮
对堆排序的优化,直接把较大的结点到达堆底,然后再上浮.  
堆排序几乎完美地应用了空间和时间,经常运用在嵌入式系统,但是很少用在现代系统,因为对比前面的算法,很少和相邻元素对比,利用缓存少  
但是堆实现的优先队列却非常重要,尤其是插入操作和删除最大元素操作的对数级别运行时间  

## 2.5 应用
排序算法和优先队列的应用  
排序应用:
    排序有用的一个原因: 有序好找  
    看似无关的问题,子问题也有排序问题,比如数据压缩,计算机生物学  
    书中的Java通用排序算法问题,其他系统也需要解决  
    基本涉及:科学~算法~商业领域  
本章其他章仍会提起  

### 2.5.1 将各种数据排序
实现Comparable,就可以将各种数据排序  

#### 2.5.1.1 交易事务
实现Comparable即可排序

#### 2.5.1.2 指针排序
C和C++,需要指定指针还是数据本身  
java不用  

#### 2.5.1.3 不可变的键
用来排序的键值变了,数据可能就不是有序的  

#### 2.5.1.4 廉价的交换
引用带来廉价的交换

#### 2.5.1.5 多种排序方法
使用Comparator可以轻松使用多种排序方法  
像String这种,自然语言本来就有多种排序方法,所以本身提供很多比较器

#### 2.5.1.6 多键数组
Insertion.sort(a, new Transaction.whenOrder());  
Insertion.sort(a, new Transaction.howMuchOrder());  

#### 2.5.1.7 使用比较器实现优先队列
优先队列使用比较器的方法:
    - 增加比较器的内部变量
    - 增加比较器为传参的构造器
    - 修改MaxPQ的less部分

#### 2.5.1.8 稳定性
能保留重复键值的相对位置,就叫稳定性.  
    eg. Chicago 2:00
        Chicago 3:00
        Chicago 4:00
        Los Angels 2:00
        Los Angels 3:00
        Los Angels 4:00
        -- 上面是稳定的
    eg. Chicago 2:00
        Chicago 4:00
        Chicago 3:00
        Los Angels 4:00
        Los Angels 2:00
        Los Angels 3:00
        -- 下面则不稳定
排序算法中: 插入排序和归并排序是稳定的,但是选择~希尔~快速~堆排序都是不稳定.  
    任何算法都可以弄稳定了,但需要很大的代价  

### 2.5.2 我应该使用哪种排序算法
排序算法的特点  
    - 选择 否 是 N^2 1 N次交换
    - 插入 是 是 N~N^2 1 小数组时适合使用
    - 希尔排序 否 是 N^3/2 1 中数组都适用,代码量也较少  
    - 归并排序 否 是 NlogN N 稳定且最优性能,原地归并
    - 快速排序 否 是 1/2N^2->NlogN lgN 概率最优性能,实际最快
    - 三向归并 否 是 NlogN lgN 快速排序优化版,在有重复键好使
    - 堆排序 否 是 NlogN 1 现代系统应用少,因为很少比较相邻元素,击中缓存少

#### 2.5.2.1 将原始类型数据排序

#### 2.5.2.2 Java系统库的排序算法
Java:
    原始数据用Quick3way  
    对象数据用Merge  
    
### 2.5.3 问题的规约
### 2.5.4 排序应用一览
    

