# 第1章 基础
研究适合用计算机实现的算法
1.1 Java编程模型
1.2 数据抽象~API
1.3 抽象数据类型: 背包~队列~栈.全书算法实现的起点和样板
1.4 性能. 科学式:对性能假设,建立数学模型,实验验证,必要时重复这个过程
1.5$ 连通性问题
###### 算法
算法可以被多种计算机程序实现.
数据结构是算法的副产品或结果
学习算法的主要原因就是干活更快更简单
大问题->多个小问题.有些小问题耗资源特别多.
###### 本书框架
1. 基础
实现~分析和比较算法的基本原则和方法, Java编程模型~数据抽象~基本数据结构~集合类的抽象数据类型~算法性能分析~案例分析
2. 排序
排序是重要的基础算法.插入~选择~希尔~快速~归并~堆.排序相关问题,优先队列~选举~归并
3. 查找
基本和高级的查找算法,二叉查找树~平衡查找树和散列表
4. 图
图是对象和它们的连接,连接可能有权重和方向.深度优先搜索~广度优先搜索~连通性问题,Kruskal和Prim的最小生成树算法~Dijkstra和Bellman-Ford最短路径算法
5. 字符串
字符串是重要数据类型.首先是字符串键的排序和查找快速算法,然后是子字符串查找`正则表达式模式匹配和数据压缩算法
6. 背景
前沿研究领域
## 1.1 基础编程模型
为什么用Java来实现算法?
- 程序精确~优雅~完全地描述了算法
- 运行程序学习算法的性质
- 程序可以拿来用
基础编程模型: 语言特性~库~操作系统特性
### 1.1.1 Java程序的基本结构
类~库或数据类型使用的7种语法
- 原始数据类型: 整数~浮点数~布尔值~字符型
- 语句: 声明~赋值~条件~循环~调用~返回
- 数组:
- 静态方法:
- 字符串:
- 标准输入/输出: 程序与外界联系的桥梁
- 数据抽象:

虚拟终端
java cat10.P005BinarySearch largeW.txt < largeT.txt
- largeW.txt: args[0]
- >: 输出重定向
- <: 输入重定向
### 1.1.2 原始数据类型与表达式
数据类型就是数据+操作
原始数据类型:
- 整型, int
- 浮点型, double. double可以用科学计数法
- 布尔, true false, 逻辑操作
- 字符型, char
Java程序的基本组成
- 原始数据: int~double~boolean~char
- 标识符: 首字符不能是数字,字母~数字~$~_
- 变量: 任意标识符
- 字面量: int 1 0 -42; double 2.0 1.0e-15 3.14; boolean true false; char 'a' '+' '9' '\n'(escape)
- 表达式:
#### 1.1.2.1 表达式
中缀表达式: java , 前缀表达式: Lisp
运算符优先级: 用括号消除优先级规则的依赖
#### 1.1.2.2 类型转换
#### 1.1.2.3 比较
#### 1.1.2.4 其他原始类型
### 1.1.3 语句
语句:
- 声明语句
- 赋值语句
- 条件语句
- 循环语句
- 调用和返回语句
### 1.1.4 简便记法
#### 1.1.4.1 声明并初始化
#### 1.1.4.2 隐式赋值
#### 1.1.4.3 单语句代码段
#### 1.1.4.4 for语句
### 1.1.5 数组
#### 1.1.5.1 创建并初始化数据
```java
// 完整写法
double[] a;
a = new double[N];
for(int i = 0; i < N; i++)
    a[i] = 0.0;
// 简化写法
double[] a = new double[N];
// 声明初始化
int[] a = {1, 1, 2, 3, 5, 8};
```
#### 1.1.5.2 简化写法
#### 1.1.5.3 使用数组
典型的数组处理代码
```java
// 找出数据最大的元素
double max = a[0];
for(int i = 1; i < a.length; i++)
    if(a[i]>max) max= a[i];
// 计算数组元素的平均值
```
#### 1.1.5.4 起别名
#### 1.1.5.5 二维数据
### 1.1.6 静态方法
要么是数据类型,要么是静态方法库
#### 1.1.6.1 静态方法
典型静态方法实现
```java
//MathUtils.java
```
#### 1.1.6.2 调用静态方法
产生副作用
#### 1.1.6.3 方法的性质
- 方法的参数按值传递:
- 方法名可以被重载
- 方法只能返回一个值,但可以包含多个返回语句
- 方法可以产生副作用
#### 1.1.6.4 递归
编写递归代码三点:
- 递归总有一个最简单情况
- 递归调用总是解决规模更小的子问题,递归才能收敛到最简单情况.规模更小:越来越接近最简单情况
- 递归调用的父问题与子问题不应该有交集. BinarySearch (lo, hi)的子问题(mid + 1, hi) 或 (lo, mid - 1)非常容易重复mid
#### 1.1.6.5 基础编程模型
#### 1.1.6.6 模块化编程
模块化好处:
- 代码大时,每次处理模块大小适中
- 共享和重用代码
- 容易用改进的实现替换老的实现
- debug时可以建立合适的抽象盒子
- 缩小调试范围
#### 1.1.6.7 单元测试
Java的最佳实践之一: 每个main函数测试库中的所有方法.
每个main():都可以当作测试用例,复杂了甚至可以独立成模块.
#### 1.1.7.8 外部库
- java.lang.*: Math,Integer,Double,String,StringBuilder
- java.util.Arrays:用的不多
- 书的其他库: 比如BinarySearch
- 开发的Std*库:
### 1.1.7 API
API: 应用程序编程接口(文档),方法名称`签名和简短的描述
用例: 使用API的代码
实现: 实现API的Java代码
#### 1.1.7.1 举例
#### 1.1.7.2 Java库
#### 1.1.7.3 我们的标准库
```java
public interface StdRandom {
    static void setSeed(long seed);
    static double random();
    static int uniform(int N);
    static int uniform(int lo, int hi);
    static double uniform(double lo, double hi);
    static boolean bernoulli(double p); //返回真概率为p
    static double gaussian(); //正态分布
    static double gaussian(double m, double s);
    static int discrete(double[] a); //返回i的概率为a[i]
    static void shuffle(double[] a); //数组a随机排序
}
```
```java
//数据分析静态方法库
public interface  StdStats {
    static double max(double[] a);
    static double min(double[] a);
    static double mean(double[] a);
    static double var(double[] a); //采样方差
    static double stddev(double[] a);// 采样标准差
    static double median(double[] a); //中位数
}
```
为什么要弄库?
- ignore details
- 大量测试,覆盖极端和罕见的情况,值得信任
#### 1.1.7.4 你自己编写的库
应该将自己编写的每一个程序都当作日后可以重用的库
- 编写用例,实现中将计算过程分解成可控的部分
- 明确静态方法库和与之对应的API
- 实现API和能够对方法进行独立测试的main()函数

API: 这是一份契约,调用者和实现者都要能遵守这份契约
### 1.1.8 字符串
#### 1.1.8.1 字符串拼接
#### 1.1.8.2 类型转换
屏幕上只能显示字符串 toString()
#### 1.1.8.3 自动转换
#### 1.1.8.4 命令行参数
args: 命令行参数
### 1.1.9 输入输出
标准输入~输出和绘图库的作用都是Java和外界交流
#### 1.1.9.1 命令和参数
#### 1.1.9.2 标准输出
#### 1.1.9.3 格式化输出
格式字符串的转换代码和被转换的数据类型必须匹配
printf()格式化方法
#### 1.1.9.4 标准输入
```java
public interface StdIn {
    static boolean isEmpty();
    static int readInt();
    static double readDouble();
    static long readLong();
    static boolean readBoolean();
    static char readChar();
    static byte readByte();
    static String readString();
    static boolean hasNextLine();
    static String readLine();
    static String readAll();
}
```
#### 1.1.9.5 重定向与管道
可以将输出重定向到另一个文件.文件内容可以永久保存,也可以作为另一程序的输入
- % java RandomSeq 1000 100.0 200.0 > data.txt
- >: 从文件获取输入,而不是从标准输入获取
- <: 输出到文件,而不是输出到标准输出
将一个程序输出重定向到另一个程序的输入叫做管道
- % java RandomSeq 1000 100.0 200.0 | java Average
#### 1.1.9.6 基于文件的输入输出
从文件中读取和写入数组
```java
public interface In {
    static int[] readInts(String name);
    static double[] readDoubles(String name);
    static String[] readStrings(String name);
}
public interface Out {
    static void write(int[] a, String name);
    static void write(double[] a, String name);
    static void write(String[] a, String name);
}
```
#### 1.1.9.7 标准绘图库(基本方法)
#### 1.1.9.8 标准绘图库(控制方法)
控制方法:
- 画布大小和比例
- 直线颜色和宽度
- 文本字体
- 绘图时间(用于动画)
```java
public interface StdDraw {
    static void setXscale(double x0, double x1);
    static void setYscale(double y0, double y1);
    static void setPenRadius(double r);
    static void setPenColor(Color c);
    static void setFont(Font f);
    static void setCanvasSzie(int w, int h);
    static void clear(Color c);
    static void show(int dt);
}
```
### 1.1.10 二分查找
#### 1.1.10.1 二分查找
#### 1.1.10.2 开发用例
#### 1.1.10.3 白名单过滤
如果可能,测试用例都通过模拟实际情况来展示当前算法的必要性.
eg: 一家信用卡公司,检查客户的交易账号是否有效.需要
- 将客户账号保存在一个文件中,称为白名单
- 从标准输入中得到每笔交易的账号
- 在标准输出中打印出所有与任何客户无关的账号,公司很可能拒绝此类交易
#### 1.1.10.4 性能
程序往往只是可用还是不够的
粗略地说编程模型的目标是: 代码能跑起来,可以处理数据,不同情况下修改实现,理解它什么时候能用(可应用性)
```java
public class Demo {
public static int rank(int key, int[] a) {
    for (int i = 0; i < a.length; i++)
        if (a[i] == key) return i;
    return -1;
}
}
```
### 1.1.11 展望
数据抽象比静态方法更进一步
- 模块化
- 构造链式数据结构
- 准确定义面对的算法问题

## 1.2 数据抽象
数据类型:一组值和一组对这些值的操作的集合  
抽象数据类型(ADT):
- 用API准确地定义问题
- 用API的实现描述算法和数据结构
### 1.2.1 使用抽象数据类型
定义~创建~使用
#### 1.2.1.1 抽象数据类型的API
```java
public class Counter {
    public Counter(String id);
    public void increment() {
    }
    public int tally() {
    }
}
```
#### 1.2.1.2 继承的方法
都会继承Object
- toString()
- equals()
- compareTo()
- hashCode()
#### 1.2.1.3 用例代码
用例代码也分开模块化
#### 1.2.1.4 对象
对象:
- 状态
- 标识
- 行为
#### 1.2.1.5 创建对象
每次调用new():
- 分配空间
- 调用构造函数 初始化对象的值
- 返回引用
#### 1.2.1.6 调用实例方法
#### 1.2.1.7 使用对象
#### 1.2.1.8 赋值语句
#### 1.2.1.9 将对象作为参数
高阶函数
#### 1.2.1.10 将对象作为返回值
高阶函数
#### 1.2.1.11 数组也是对象
#### 1.2.1.12 对象的数组
### 1.2.2 抽象数据类型举例
用到的数据类型:
- java.lang.*
- java标准库: java.net,java.io
- I/O, StdIn和StdOut
- 面向数据类型抽象类型
- 集合类: Bag`Stack~Queue
- 面向操作的抽象数据类型
- 图算法相关
#### 1.2.2.1 几何对象
#### 1.2.2.2 信息处理
#### 1.2.2.3 字符串
```java
public class String {
    String();
    int length();
    int charAt(int i);
    int indexOf(String p);
    int indexOf(String p, int i);
    String concat(String t);
    String substring(int i, int j);
    String[] split(String delim);
    int compareTo(String t);
    boolean equals(String t);
    int hashCode();
}
```
\\s+: 一个或多个制表符~空格~换行符或回车
#### 1.2.2.4 再谈输入输出
### 1.2.3 抽象数据类型的实现
#### 1.2.3.1 实例变量
#### 1.2.3.2 构造函数
#### 1.2.3.3 实例方法
#### 1.2.3.4 作用域
#### 1.2.3.5 API`用例与实现
三步走开发数据类型:
- 定义一份API
- 用Java类实现API
- 实现多个测试用例验证前两步
### 1.2.4 更多抽象数据类型的实现
理解抽象数据类型的威力和用法,研究更多例子和实现
#### 1.2.4.1 日期
日期的两种实现:(都要检查数据,例: 6月31,2月29非法日期)
1. 日月年三个值
2. 512y + 32m+d: 基于日从0~31,月从0~15,年为正.
区别: 性能, 用例需要
1. 空间大,时间少
2. 空间少,时间大
有些需要1,有些需要2
#### 1.2.4.2 维护多个实现
维护多个实现的命名约定
- 前缀修饰符区分BasicDate和SmallDate
- 不用前缀的Date, 适用于大多数用例
#### 1.2.4.3 累加器
#### 1.2.4.4 可视化的累加器
只需改变构造器,就可以拥有可视化的收益
### 1.2.5 数据类型的设计
抽象数据类型是一种向用例隐藏内部表示的数据类型
#### 1.2.5.1 封装
#### 1.2.5.2 设计API
一份优秀的API付出的时间,都可以从调试和代码复用节省的时间获得汇报.
优秀的API:
- API说明所有可能的输入和副作用
- 先写出检查实现是否与API相符的程序
API的陷阱: 只为用例提供需要的,仅此而已
- API难以实现
- API难以使用,用例代码比没有API时更复杂
- API范围太窄,方法太少
- API范围太宽,方法太多
- API太粗略: 抽象不够有效
- API太详细: 过于细致无法使用
- API依赖特定的数据表示: 用例代码无法从数据表示的细节解脱出来
#### 1.2.5.3 算法和抽象数据类型
#### 1.2.5.4 接口继承
比较和迭代的典型用法
#### 1.2.5.5 实现继承
#### 1.2.5.6 字符串表示的习惯
#### 1.2.5.7 封装类型
int+ String->Integer+ String->Integer.toString() + String 类型塔
#### 1.2.5.8 等价性
equals:
- 自反性: x.equals(x) 为 true
- 对称性: y.equals(x) == x.equals(y)
- 传递性
- 一致性: 两个对象没有修改过,反复调用x.equals(y)总是返回相同的值
- 非空性: x.equals(null)总是返回false
做到以上性质
- 引用相同
- 传递性
- 一致性: 两个对象没有修改过,反复调用x.equals(y)总是返回相同的值
- 非空性: x.equals(null)总是返回false
做到以上性质:date.equals(object)
1. 引用相同,直接true
2. 参数为null,返回false
3. 类不同,false
4. Object转入Date
5. 实例变量的值不同,返回false
#### 1.2.5.9 内存管理
孤儿对象: 编程语言和系统某种机制必要时分配内存,不需要时释放内存  
内存管理: 垃圾回收
- 原始数据类型:很容易, 因为内存分配需要的信息编译阶段就能获取
- 对象:创建对象时分配内存,执行时决定了对象变为孤儿,系统并不能准确知道何时释放对象的内存.Java记录孤儿对象,并将内存释放到内存池中.
#### 1.2.5.10 不可变性
不可变数据类型: Date,对象中的值创建之后无法再被改变.  
1.
```java
Date d = new Date();
Date d0 = d;
//d0的值改变后,d的值也会改变.用final可以避免
```
2. 
需要为每个值创建新对象  
实例变量含有final,那么永远指向同一个的对象,但是对象的值仍然可以改变
#### 1.2.5.11 契约式设计
- Exception:
- Assertion:
#### 1.2.5.12 异常与错误
异常和错误:程序运行中出现破坏性事件  
- StackOverflowError:
- ArithmeticException:
- ArrayIndexOutOfBoundsException:
- OutOfMemoryError:
- NullPointerException:
- 自定义: throw new RuntimeException("Error message here");
#### 1.2.5.13 断言
#### 1.2.5.14 小结
- 实现继承的问题:
1. 父类的任何改动都会影响它的子类.脆弱的基类问题.
2. 子类代码可能会扭曲父类代码的意图







