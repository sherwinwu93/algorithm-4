# 第1章 基础
研究适合用计算机实现的算法
1.1 Java编程模型
1.2 数据抽象~API
1.3 抽象数据类型: 背包~队列~栈.全书算法实现的起点和样板
1.4 性能. 科学式:对性能假设,建立数学模型,实验验证,必要时重复这个过程
1.5$ 连通性问题
###### 算法
算法可以被多种计算机程序实现.
数据结构是算法的副产品或结果
学习算法的主要原因就是干活更快更简单
大问题->多个小问题.有些小问题耗资源特别多.
###### 本书框架
1. 基础
实现~分析和比较算法的基本原则和方法, Java编程模型~数据抽象~基本数据结构~集合类的抽象数据类型~算法性能分析~案例分析
2. 排序
排序是重要的基础算法.插入~选择~希尔~快速~归并~堆.排序相关问题,优先队列~选举~归并
3. 查找
基本和高级的查找算法,二叉查找树~平衡查找树和散列表
4. 图
图是对象和它们的连接,连接可能有权重和方向.深度优先搜索~广度优先搜索~连通性问题,Kruskal和Prim的最小生成树算法~Dijkstra和Bellman-Ford最短路径算法
5. 字符串
字符串是重要数据类型.首先是字符串键的排序和查找快速算法,然后是子字符串查找`正则表达式模式匹配和数据压缩算法
6. 背景
前沿研究领域
## 1.1 基础编程模型
为什么用Java来实现算法?
- 程序精确~优雅~完全地描述了算法
- 运行程序学习算法的性质
- 程序可以拿来用
基础编程模型: 语言特性~库~操作系统特性
### 1.1.1 Java程序的基本结构
类~库或数据类型使用的7种语法
- 原始数据类型: 整数~浮点数~布尔值~字符型
- 语句: 声明~赋值~条件~循环~调用~返回
- 数组:
- 静态方法:
- 字符串:
- 标准输入/输出: 程序与外界联系的桥梁
- 数据抽象:

虚拟终端
java cat10.P005BinarySearch largeW.txt < largeT.txt
- largeW.txt: args[0]
- >: 输出重定向
- <: 输入重定向
### 1.1.2 原始数据类型与表达式
数据类型就是数据+操作
原始数据类型:
- 整型, int
- 浮点型, double. double可以用科学计数法
- 布尔, true false, 逻辑操作
- 字符型, char
Java程序的基本组成
- 原始数据: int~double~boolean~char
- 标识符: 首字符不能是数字,字母~数字~$~_
- 变量: 任意标识符
- 字面量: int 1 0 -42; double 2.0 1.0e-15 3.14; boolean true false; char 'a' '+' '9' '\n'(escape)
- 表达式:
#### 1.1.2.1 表达式
中缀表达式: java , 前缀表达式: Lisp
运算符优先级: 用括号消除优先级规则的依赖
#### 1.1.2.2 类型转换
#### 1.1.2.3 比较
#### 1.1.2.4 其他原始类型
### 1.1.3 语句
语句:
- 声明语句
- 赋值语句
- 条件语句
- 循环语句
- 调用和返回语句
### 1.1.4 简便记法
#### 1.1.4.1 声明并初始化
#### 1.1.4.2 隐式赋值
#### 1.1.4.3 单语句代码段
#### 1.1.4.4 for语句
### 1.1.5 数组
#### 1.1.5.1 创建并初始化数据
```java
// 完整写法
double[] a;
a = new double[N];
for(int i = 0; i < N; i++)
    a[i] = 0.0;
// 简化写法
double[] a = new double[N];
// 声明初始化
int[] a = {1, 1, 2, 3, 5, 8};
```
#### 1.1.5.2 简化写法
#### 1.1.5.3 使用数组
典型的数组处理代码
```java
// 找出数据最大的元素
double max = a[0];
for(int i = 1; i < a.length; i++)
    if(a[i]>max) max= a[i];
// 计算数组元素的平均值
```
#### 1.1.5.4 起别名
#### 1.1.5.5 二维数据
### 1.1.6 静态方法
要么是数据类型,要么是静态方法库
#### 1.1.6.1 静态方法
典型静态方法实现
```java
//MathUtils.java
```
#### 1.1.6.2 调用静态方法
产生副作用
#### 1.1.6.3 方法的性质
- 方法的参数按值传递:
- 方法名可以被重载
- 方法只能返回一个值,但可以包含多个返回语句
- 方法可以产生副作用
#### 1.1.6.4 递归
编写递归代码三点:
- 递归总有一个最简单情况
- 递归调用总是解决规模更小的子问题,递归才能收敛到最简单情况.规模更小:越来越接近最简单情况
- 递归调用的父问题与子问题不应该有交集. BinarySearch (lo, hi)的子问题(mid + 1, hi) 或 (lo, mid - 1)非常容易重复mid
#### 1.1.6.5 基础编程模型
#### 1.1.6.6 模块化编程
模块化好处:
- 代码大时,每次处理模块大小适中
- 共享和重用代码
- 容易用改进的实现替换老的实现
- debug时可以建立合适的抽象盒子
- 缩小调试范围
#### 1.1.6.7 单元测试
Java的最佳实践之一: 每个main函数测试库中的所有方法.
每个main():都可以当作测试用例,复杂了甚至可以独立成模块.
#### 1.1.7.8 外部库
- java.lang.*: Math,Integer,Double,String,StringBuilder
- java.util.Arrays:用的不多
- 书的其他库: 比如BinarySearch
- 开发的Std*库:
### 1.1.7 API
API: 应用程序编程接口(文档),方法名称`签名和简短的描述
用例: 使用API的代码
实现: 实现API的Java代码
#### 1.1.7.1 举例
#### 1.1.7.2 Java库
#### 1.1.7.3 我们的标准库
```java
public interface StdRandom {
    static void setSeed(long seed);
    static double random();
    static int uniform(int N);
    static int uniform(int lo, int hi);
    static double uniform(double lo, double hi);
    static boolean bernoulli(double p); //返回真概率为p
    static double gaussian(); //正态分布
    static double gaussian(double m, double s);
    static int discrete(double[] a); //返回i的概率为a[i]
    static void shuffle(double[] a); //数组a随机排序
}
```
```java
//数据分析静态方法库
public interface  StdStats {
    static double max(double[] a);
    static double min(double[] a);
    static double mean(double[] a);
    static double var(double[] a); //采样方差
    static double stddev(double[] a);// 采样标准差
    static double median(double[] a); //中位数
}
```
为什么要弄库?
- ignore details
- 大量测试,覆盖极端和罕见的情况,值得信任
#### 1.1.7.4 你自己编写的库
应该将自己编写的每一个程序都当作日后可以重用的库
- 编写用例,实现中将计算过程分解成可控的部分
- 明确静态方法库和与之对应的API
- 实现API和能够对方法进行独立测试的main()函数

API: 这是一份契约,调用者和实现者都要能遵守这份契约
### 1.1.8 字符串
#### 1.1.8.1 字符串拼接
#### 1.1.8.2 类型转换
屏幕上只能显示字符串 toString()
#### 1.1.8.3 自动转换
#### 1.1.8.4 命令行参数
args: 命令行参数
### 1.1.9 输入输出
标准输入~输出和绘图库的作用都是Java和外界交流
#### 1.1.9.1 命令和参数
#### 1.1.9.2 标准输出
#### 1.1.9.3 格式化输出
格式字符串的转换代码和被转换的数据类型必须匹配
printf()格式化方法
#### 1.1.9.4 标准输入
```java
public interface StdIn {
    static boolean isEmpty();
    static int readInt();
    static double readDouble();
    static long readLong();
    static boolean readBoolean();
    static char readChar();
    static byte readByte();
    static String readString();
    static boolean hasNextLine();
    static String readLine();
    static String readAll();
}
```
#### 1.1.9.5 重定向与管道
可以将输出重定向到另一个文件.文件内容可以永久保存,也可以作为另一程序的输入
- % java RandomSeq 1000 100.0 200.0 > data.txt
- >: 从文件获取输入,而不是从标准输入获取
- <: 输出到文件,而不是输出到标准输出
将一个程序输出重定向到另一个程序的输入叫做管道
- % java RandomSeq 1000 100.0 200.0 | java Average
#### 1.1.9.6 基于文件的输入输出
从文件中读取和写入数组
```java
public interface In {
    static int[] readInts(String name);
    static double[] readDoubles(String name);
    static String[] readStrings(String name);
}
public interface Out {
    static void write(int[] a, String name);
    static void write(double[] a, String name);
    static void write(String[] a, String name);
}
```
#### 1.1.9.7 标准绘图库(基本方法)
#### 1.1.9.8 标准绘图库(控制方法)
控制方法:
- 画布大小和比例
- 直线颜色和宽度
- 文本字体
- 绘图时间(用于动画)
```java
public interface StdDraw {
    static void setXscale(double x0, double x1);
    static void setYscale(double y0, double y1);
    static void setPenRadius(double r);
    static void setPenColor(Color c);
    static void setFont(Font f);
    static void setCanvasSzie(int w, int h);
    static void clear(Color c);
    static void show(int dt);
}
```
### 1.1.10 二分查找
#### 1.1.10.1 二分查找
#### 1.1.10.2 开发用例
#### 1.1.10.3 白名单过滤
如果可能,测试用例都通过模拟实际情况来展示当前算法的必要性.
eg: 一家信用卡公司,检查客户的交易账号是否有效.需要
- 将客户账号保存在一个文件中,称为白名单
- 从标准输入中得到每笔交易的账号
- 在标准输出中打印出所有与任何客户无关的账号,公司很可能拒绝此类交易
#### 1.1.10.4 性能
程序往往只是可用还是不够的
粗略地说编程模型的目标是: 代码能跑起来,可以处理数据,不同情况下修改实现,理解它什么时候能用(可应用性)
```java
public class Demo {
public static int rank(int key, int[] a) {
    for (int i = 0; i < a.length; i++)
        if (a[i] == key) return i;
    return -1;
}
}
```
### 1.1.11 展望
数据抽象比静态方法更进一步
- 模块化
- 构造链式数据结构
- 准确定义面对的算法问题

## 1.2 数据抽象
数据类型:一组值和一组对这些值的操作的集合  
抽象数据类型(ADT):
- 用API准确地定义问题
- 用API的实现描述算法和数据结构
### 1.2.1 使用抽象数据类型
定义~创建~使用
#### 1.2.1.1 抽象数据类型的API
```java
public class Counter {
    public Counter(String id);
    public void increment() {
    }
    public int tally() {
    }
}
```
#### 1.2.1.2 继承的方法
都会继承Object
- toString()
- equals()
- compareTo()
- hashCode()
#### 1.2.1.3 用例代码
用例代码也分开模块化
#### 1.2.1.4 对象
对象:
- 状态
- 标识
- 行为
#### 1.2.1.5 创建对象
每次调用new():
- 分配空间
- 调用构造函数 初始化对象的值
- 返回引用
#### 1.2.1.6 调用实例方法
#### 1.2.1.7 使用对象
#### 1.2.1.8 赋值语句
#### 1.2.1.9 将对象作为参数
高阶函数
#### 1.2.1.10 将对象作为返回值
高阶函数
#### 1.2.1.11 数组也是对象
#### 1.2.1.12 对象的数组
### 1.2.2 抽象数据类型举例
用到的数据类型:
- java.lang.*
- java标准库: java.net,java.io
- I/O, StdIn和StdOut
- 面向数据类型抽象类型
- 集合类: Bag`Stack~Queue
- 面向操作的抽象数据类型
- 图算法相关
#### 1.2.2.1 几何对象
#### 1.2.2.2 信息处理
#### 1.2.2.3 字符串
```java
public class String {
    String();
    int length();
    int charAt(int i);
    int indexOf(String p);
    int indexOf(String p, int i);
    String concat(String t);
    String substring(int i, int j);
    String[] split(String delim);
    int compareTo(String t);
    boolean equals(String t);
    int hashCode();
}
```
\\s+: 一个或多个制表符~空格~换行符或回车
#### 1.2.2.4 再谈输入输出
### 1.2.3 抽象数据类型的实现
#### 1.2.3.1 实例变量
#### 1.2.3.2 构造函数
#### 1.2.3.3 实例方法
#### 1.2.3.4 作用域
#### 1.2.3.5 API`用例与实现
三步走开发数据类型:
- 定义一份API
- 用Java类实现API
- 实现多个测试用例验证前两步
### 1.2.4 更多抽象数据类型的实现
理解抽象数据类型的威力和用法,研究更多例子和实现
#### 1.2.4.1 日期
日期的两种实现:(都要检查数据,例: 6月31,2月29非法日期)
1. 日月年三个值
2. 512y + 32m+d: 基于日从0~31,月从0~15,年为正.
区别: 性能, 用例需要
1. 空间大,时间少
2. 空间少,时间大
有些需要1,有些需要2
#### 1.2.4.2 维护多个实现
维护多个实现的命名约定
- 前缀修饰符区分BasicDate和SmallDate
- 不用前缀的Date, 适用于大多数用例
#### 1.2.4.3 累加器
#### 1.2.4.4 可视化的累加器
只需改变构造器,就可以拥有可视化的收益
### 1.2.5 数据类型的设计
抽象数据类型是一种向用例隐藏内部表示的数据类型
#### 1.2.5.1 封装
#### 1.2.5.2 设计API
一份优秀的API付出的时间,都可以从调试和代码复用节省的时间获得汇报.
优秀的API:
- API说明所有可能的输入和副作用
- 先写出检查实现是否与API相符的程序
API的陷阱: 只为用例提供需要的,仅此而已
- API难以实现
- API难以使用,用例代码比没有API时更复杂
- API范围太窄,方法太少
- API范围太宽,方法太多
- API太粗略: 抽象不够有效
- API太详细: 过于细致无法使用
- API依赖特定的数据表示: 用例代码无法从数据表示的细节解脱出来
#### 1.2.5.3 算法和抽象数据类型
#### 1.2.5.4 接口继承
比较和迭代的典型用法
#### 1.2.5.5 实现继承
#### 1.2.5.6 字符串表示的习惯
#### 1.2.5.7 封装类型
int+ String->Integer+ String->Integer.toString() + String 类型塔
#### 1.2.5.8 等价性
equals:
- 自反性: x.equals(x) 为 true
- 对称性: y.equals(x) == x.equals(y)
- 传递性
- 一致性: 两个对象没有修改过,反复调用x.equals(y)总是返回相同的值
- 非空性: x.equals(null)总是返回false
做到以上性质
- 引用相同
- 传递性
- 一致性: 两个对象没有修改过,反复调用x.equals(y)总是返回相同的值
- 非空性: x.equals(null)总是返回false
做到以上性质:date.equals(object)
1. 引用相同,直接true
2. 参数为null,返回false
3. 类不同,false
4. Object转入Date
5. 实例变量的值不同,返回false
#### 1.2.5.9 内存管理
孤儿对象: 编程语言和系统某种机制必要时分配内存,不需要时释放内存  
内存管理: 垃圾回收
- 原始数据类型:很容易, 因为内存分配需要的信息编译阶段就能获取
- 对象:创建对象时分配内存,执行时决定了对象变为孤儿,系统并不能准确知道何时释放对象的内存.Java记录孤儿对象,并将内存释放到内存池中.
#### 1.2.5.10 不可变性
不可变数据类型: Date,对象中的值创建之后无法再被改变.  
1.
```java
Date d = new Date();
Date d0 = d;
//d0的值改变后,d的值也会改变.用final可以避免
```
2. 
需要为每个值创建新对象  
实例变量含有final,那么永远指向同一个的对象,但是对象的值仍然可以改变
#### 1.2.5.11 契约式设计
- Exception:
- Assertion:
#### 1.2.5.12 异常与错误
异常和错误:程序运行中出现破坏性事件  
- StackOverflowError:
- ArithmeticException:
- ArrayIndexOutOfBoundsException:
- OutOfMemoryError:
- NullPointerException:
- 自定义: throw new RuntimeException("Error message here");
#### 1.2.5.13 断言
#### 1.2.5.14 小结
- 实现继承的问题:
1. 父类的任何改动都会影响它的子类.脆弱的基类问题.
2. 子类代码可能会扭曲父类代码的意图
## 1.3 背包`队列和栈
1. 说明我们对对象的集合的表示方法直接影响各种操作的效率
2. 泛型与迭代
3. 链式结构的重要性
先API和用例,再表示方法和操作的实现
### 1.3.1 API
```java
// 背包
public class Bag<Item> implements Iterable<Item> {
    Bag();
    void add(Item item);
    boolean isEmpty();
    int size();
}
// 队列
public class Queue<Item> implements Iterable<Item> {
    Queue();
    void enqueue(Item item);
    Item dequeue();
    boolean isEmpty();
    int size();
}
// 栈 LIFO
public class Stack<Item> implements Iterable<Item> {
    Stack();
    void push(Item item);
    Item pop();
    boolean isEmpty();
    int size();
}
```
#### 1.3.1.1 泛型
#### 1.3.1.2 自动装箱
#### 1.3.1.3 可迭代的集合类型
implements Iterable
#### 1.3.1.4 背包
背包不支持删除数据,收集元素并迭代遍历所有数据
#### 1.3.1.5 先进先出队列
#### 1.3.1.6 下压栈
1. 邮件
2. 上网前进回退
#### 1.3.1.7 算术表达式求值
(1 + ((2 + 3)* (4 *5)))
明确的递归定义:
- 算术表达式可能是一个数,或者左括号~算术表达式~运算符~算术表达式和右括号组成的.
Dijkstra中序算术: 遇到右括号时,将子表达式运算出结果,代替子表达式,最后表达式一定是最简单的
- 将操作数压入操作数栈
- 将运算符压入运算符栈
- 忽略左括号
- 遇到右括号,弹出一个运算符,弹出所需数量的操作数,将计算出的结果压入栈中
### 1.3.2 集合类数据类型的实现
#### 1.3.2.1 定容栈
容量固定的字符串栈的抽象数据类型  
实现API: 第一步选择数据的表示方式  
#### 1.3.2.2 调整数组大小
动态调整数组大小,既足以保存元素,又不浪费过多空间
```java
private void resize(int max) {
    Item[] temp = (Item[]) new Object[max];
    for(int i = 0; i < N; i++)
        temp[i] = a[i];
    a = temp;
}
```
#### 1.3.2.4 对象游离
对象游离,吃空饷不干活
#### 1.3.2.5 迭代
```java
public class Demon {
    public static void main(String[] args){
      Stack<String> collection = new Stack<>();
        for (String s : collection)
            StdOut.println(s);
        Iterator<String> i = collection.iterator();
        while (i.hasNext()) {
            String s = i.next();
            StdOut.println(s);
        }
    }
}
```
集合数据类型要使用迭代需要实现
- 实现iterator(),返回Iterator对象
- Iterator类必须包含两个方法: hasNext()和next()

用例的角度:
- 无需改变用例代码可以随意切换不同的表示方法
- 无需知晓类的实现细节就能使用迭代

### 1.3.3 链表
克服reszie的缺陷  
定义: 链表是递归的数据结构,或者null,或者指向node的引用,node含有item和另一条链表的引用
#### 1.3.3.1 结点记录
```java
//嵌套类
private class Node {
    Item item;
    Node next;
}
```
上门的类型叫记录,不是抽象数据类型.但是我们实现中,Node虽然不抽象,但是Node的用例抽象了
#### 1.3.3.2 构造链表
```java
// to be or
Node first = new Node();
Node second = new Node();
Node third = new Node();
first.item = "to";
second.item = "be";
third.item = "or";
first.next = second;
second.next = third;
```
链表表示的是一列元素
#### 1.3.3.3 在表头插入结点
```java
Node oldFirst = first;
first = new Node;
first.item = "not";
first.next = oldFirst
```
#### 1.3.3.4 在表头删除结点
```java
first = first.next;
```
#### 1.3.3.5 在表尾插入结点
```java
Node oldLast = last;
last = new Node();
last = "to"
oldLast.next = last;
```
#### 1.3.3.6 其他位置的插入和删除操作
实现了以下操作:
- 表头插入结点
- 表头删除结点
- 表尾插入结点
不容易实现:(使用双向链表,但是我们所有实现都不需要)
- 删除指定的结点
- 指定结点前插入新结点
#### 1.3.3.7 遍历
```java
for(Node x = first; x != null; x = x.next) {
    // 处理x.item
}
```
#### 1.3.3.8 栈的实现
链表达到了最优的设计目标
- 任意类型数据
- 空间O(n)
- 时间O(1)
用链表数据机构,少量代码取得了期望的效果.算法和数据结构是相辅相成的
#### 1.3.3.9 队列的实现
安全指针~自动垃圾回收~抽象数据类型的使用使我们把链表封装在几个类中
#### 1.3.3.10 背包的实现
Bag: 后进先出,但是顺序不重要
### 1.3.4 综述
支持泛型和迭代的背包~队列和栈的实现的抽象使我们能够编写简洁的用例程序来操作对象的集合  
深入理解这些抽象数据类型是研究算法和数据结构的开始:
1. 这些数据类型为基石,构造更高级的数据结构
2. 展示了数据结构和算法的关系,以及同时满足多个有冲突的性能目标面对的挑战
3. 以后的算法实现重点需要支持对对象集合的强大操作
###### 数据结构
对象集合的表示方式: 数组(顺序存储)和链表(链式存储)  
eg.二叉树~复合型数据结构~数组的背包表示图

数据结构:
- 数组: 通过索引可以直接访问任意元素, 在初始化就需要知道元素的数量
- 链表: 使用空间大小和元素数量成正比, 需要通过引用访问任意元素  

研究新的应用领域时,按照以下步骤识别目标并使用数据抽象解决问题:
- 定义API
- 用例代码
- 数据结构,根据API定义实例变量
- 实现算法
- 分析算法的性能特点
## 1.4 算法分析
产生疑问:
1. 多久?
2. 多大?
答案:
科学方法: 数学分析建立模型,实验数据验证模型
### 1.4.1 科学方案
科学家理解自然世界的方法: 可重现的(他人可以验证假设的真实性)可证伪的
- 细致地观察真实世界的特点,通常还要有精确的测量
- 根据观察结果提出假设模型
- 根据模型预测未来的事件
- 继续观察并核实预测的准确性
- 如何反复直到确认预测和观察一致
### 1.4.2 观察
第一个挑战: 定量测量程序的运行时间  
问题的规模: 可以是输入的大小或者某个命令行的值.   
根据直觉,运行时间随问题规模的增长而增长,但是运行时间的增长有多快   
运行时间和输入无关,取决于问题规模  
### 1.4.2.1 举例
$: java ThreeSum 1Mints.txt
1. 有多少组?
2. 消耗的时间能接受吗?
3. 规模N和ThreeSum的运行时间的关系?
### 1.4.2.2 计时器
把几秒种~几分钟程序和几天~几个月完成的程序分开  
### 1.4.2.3 实验数据的分析
幂次法则: T(N)=aN^b, lg(T(N)) = 3*lg(N) + lg(a)  
### 1.4.3 数学模型
消耗时间:
1. 执行每条语句的耗时: 取决于计算机~Java编译器~操作系统
2. 执行每条语句的频率: 程序本身和输入
### 1.4.3.1 近似
N(N-1)(M-2)/6 = N^3/6 - N^2/2 + N/3  
幂函数和对数函数为什么经常遇到?
### 1.4.3.2 近似运行时间
Java编译器->机器指令数->每条运行时间->总运行时间  
执行语句按执行频率分块  
内循环: 执行最频繁的指令.许多程序的运行时间都只取决于一小部分指令
### 1.4.3.3 对增长数量级的猜想
1.4.2.3的实验和表1.4.4的数学模型都支持,T(N)~aN^3.增长数量级为N^3  
### 1.4.3.4 算法的分析
增长数量级对算法不论在任何计算机都是如此
### 1.4.3.5 成本模型
3-sum的暴力算法,~N^3/2  
访问三个整数,访问了~N^3/6次  
成本模型的增长数量级与增长数量级相同.研究算法的数学性质(命题)并对实现的性能作出猜想(性质),用实验验证这些猜想.
### 1.4.3.6 总结
要得到程序的数学模型:
- 确定输入模型,定义问题规模
- 识别内循环
- 根据内循环的操作确定成本模型
- 对给定的输入,判断操作的执行频率.可能需要数学分析
二分查找:  
- 输入模型: int[] a = new int[N]
- 内循环: while {}
- 成本模型: 比较操作. 比较次数最多是lgN + 1

白名单:
- 输入模型: 白名单的大小N和标准输入的M个整数.假设M>>N
- 内循环: while循环中的所有语句
- 成本模型: 比较操作lgN+1
- 分析: 比较次数M(lgN + 1) 
增长数量级最多为MlgN;
- 如果N小,那么输入-输出主要成本
- 比较的次数取决于-- ~M和~MlgN之间
- 假设Arrays.sort()成本远小于MlgN. Arrays.sort()使用的是归并排序,NlogN.所以是合理的  
得出结论: 标准输入加倍,时间加倍.白名单加倍,运行时间只是稍有增加
###### 表1.4.5 算法分析中的常见函数
算法分析中的常见函数:
- 向下取整
- 向上取整
- 自然对数
- 2为底的对数
- 2为底的整型对数(N的二进制表示的位数-1)
- 调和级数: 1+1/2+1/3+...+1/N
- 阶乘: N!
近似函数
- 调和级数求和 ~lnN
- 等差级数求和 ~N^2/2
- 等比数列求和 ~2N N=2^n
- 斯特灵公式 lgN! = lg1+ lg2+ lg3...+lgN ~NlgN
- 二项式系数 (N k) ~N^k/k! k是小常数
- 指数函数 (1 - 1/x)^x ~ 1/e
### 1.4.4 增长数量级的分类
增长数量级常见假设的总结:
- 常数级别 1 普通语句
- 对数级别 logN 二分策略(二分查找)
- 线性级别 N 循环
- 线性对数级别 NlogN 分治(归并排序)
- 平方级别 N^2 双层循环(检查所有元素对)
- 立方级别 N^3 三层循环(检查所有三元组)
- 指数级别 2^x 穷举查找(检查所有子集)
#### 1.4.4.1 常数级别
#### 1.4.4.2 对数级别
#### 1.4.4.3 线性级别
#### 1.4.4.4 线性对数级别
Merge.sort()和Quick.sort()
#### 1.4.4.5 平方级别
Selection.sort()和Insertion.sort()
#### 1.4.4.6 立方级别
#### 1.4.4.7 指数级别
不可能解决大规模问题:
- 指数:但看起来是许多问题的最佳方案
- 平方: 转变为线性对数级别
- 立方: 
我们希望找到对数级别,线性级别或线性对数级别
### 1.4.5 设计更快的算法
归并+二分解决ThreeSum,问题由原来的立方变为线性对数级别
#### 1.4.5.1 热身运动2-sum
#### 1.4.5.2 3-sum问题的快速算法
#### 1.4.5.3 下界
为算法在最坏情况下的运行时间给出一个下界非常有意义  
按照以下方式解决各种新的问题:
- 实现并分析该问题的一种简单解法,暴力算法,例如ThreeSum和TwoSum
- 考察算法的各种改进,通常能降低增长数量级,例如TwoSumFast和ThreeSumFast
- 用实验证明新的算法更快
### 1.4.6 倍率实验
下面的方法可以预测任意程序的性能,并判断运行时间的大致增长数量级
- 开发输入生成器来产生实际情况下各种可能的输入
- 运行下方的DoublingRatio程序,能够计算每次实验和上一次运行时间的比值
- 反复运行知道该比值趋近于极限2^b
结论:
- 运行时间的增长数量级约为N^b
- 要预测程序的运行时间,将上次观察的时间乘以2^b并将N加倍,如此反复
#### 1.4.6.1 评估它解决大型问题的可行性
###### 表1.4.9 根据增长的数量级函数作出的预测
#### 1.4.6.2 评估使用更快的计算机所产生的价值
摩尔定律: 18个月后计算机的速度和内存会翻一番,5年后计算机的速度和内存是现在的10倍  
### 1.4.7 注意事项




