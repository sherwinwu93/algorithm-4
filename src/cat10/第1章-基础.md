# 第1章 基础
研究适合用计算机实现的算法
1.1 Java编程模型
1.2 数据抽象~API
1.3 抽象数据类型: 背包~队列~栈.全书算法实现的起点和样板
1.4 性能. 科学式:对性能假设,建立数学模型,实验验证,必要时重复这个过程
1.5$ 连通性问题
###### 算法
算法可以被多种计算机程序实现.  
数据结构是算法的副产品或结果  
学习算法的主要原因就是干活更快更简单  
大问题->多个小问题.有些小问题耗资源特别多.  
###### 本书框架
1. 基础
实现`分析和比较算法的基本原则和方法, Java编程模型~数据抽象~基本数据结构~集合类的抽象数据类型~算法性能分析~案例分析
2. 排序
排序是重要的基础算法.插入~选择~希尔~快速~归并~堆.排序相关问题,优先队列~选举~归并
3. 查找
基本和高级的查找算法,二叉查找树~平衡查找树和散列表
4. 图
图是对象和它们的连接,连接可能有权重和方向.深度优先搜索~广度优先搜索~连通性问题,Kruskal和Prim的最小生成树算法~Dijkstra和Bellman-Ford最短路径算法
5. 字符串
字符串是重要数据类型.首先是字符串键的排序和查找快速算法,然后是子字符串查找`正则表达式模式匹配和数据压缩算法
6. 背景
前沿研究领域
## 1.1 基础编程模型
为什么用Java来实现算法?
- 程序精确~优雅~完全地描述了算法
- 运行程序学习算法的性质
- 程序可以拿来用
基础编程模型: 语言特性~库~操作系统特性
### 1.1.1 Java程序的基本结构
类~库或数据类型使用的7种语法
- 原始数据类型: 整数~浮点数~布尔值~字符型
- 语句: 声明~赋值~条件~循环~调用~返回
- 数组:
- 静态方法:
- 字符串:
- 标准输入/输出: 程序与外界联系的桥梁
- 数据抽象: 

虚拟终端    
java cat10.P005BinarySearch largeW.txt < largeT.txt
- largeW.txt: args[0]
- >: 输出重定向
- <: 输入重定向
### 1.1.2 原始数据类型与表达式
数据类型就是数据+操作  
原始数据类型:
- 整型, int
- 浮点型, double. double可以用科学计数法
- 布尔, true false, 逻辑操作
- 字符型, char
Java程序的基本组成
- 原始数据: int~double~boolean~char
- 标识符: 首字符不能是数字,字母~数字~$~_
- 变量: 任意标识符
- 字面量: int 1 0 -42; double 2.0 1.0e-15 3.14; boolean true false; char 'a' '+' '9' '\n'(escape)
- 表达式: 
#### 1.1.2.1 表达式
中缀表达式: java , 前缀表达式: Lisp  
运算符优先级: 用括号消除优先级规则的依赖
#### 1.1.2.2 类型转换
#### 1.1.2.3 比较
#### 1.1.2.4 其他原始类型
### 1.1.3 语句
语句:
- 声明语句
- 赋值语句
- 条件语句
- 循环语句
- 调用和返回语句
### 1.1.4 简便记法
#### 1.1.4.1 声明并初始化
#### 1.1.4.2 隐式赋值
#### 1.1.4.3 单语句代码段
#### 1.1.4.4 for语句
### 1.1.5 数组
#### 1.1.5.1 创建并初始化数据
```java
// 完整写法
double[] a;
a = new double[N];
for(int i = 0; i < N; i++)
    a[i] = 0.0;
// 简化写法
double[] a = new double[N];
// 声明初始化
int[] a = {1, 1, 2, 3, 5, 8};
```
#### 1.1.5.2 简化写法
#### 1.1.5.3 使用数组
典型的数组处理代码
```java
// 找出数据最大的元素
double max = a[0];
for(int i = 1; i < a.length; i++) 
    if(a[i]>max) max= a[i];
// 计算数组元素的平均值
```
#### 1.1.5.4 起别名
#### 1.1.5.5 二维数据
### 1.1.6 静态方法
要么是数据类型,要么是静态方法库
#### 1.1.6.1 静态方法
典型静态方法实现
```java
//MathUtils.java
```
#### 1.1.6.2 调用静态方法
产生副作用
#### 1.1.6.3 方法的性质
- 方法的参数按值传递:
- 方法名可以被重载
- 方法只能返回一个值,但可以包含多个返回语句
- 方法可以产生副作用
#### 1.1.6.4 递归
编写递归代码三点:
- 递归总有一个最简单情况
- 递归调用总是解决规模更小的子问题,递归才能收敛到最简单情况.规模更小:越来越接近最简单情况
- 递归调用的父问题与子问题不应该有交集. BinarySearch (lo, hi)的子问题(mid + 1, hi) 或 (lo, mid - 1)非常容易重复mid
#### 1.1.6.5 基础编程模型
#### 1.1.6.6 模块化编程
模块化好处:
- 代码大时,每次处理模块大小适中
- 共享和重用代码
- 容易用改进的实现替换老的实现
- debug时可以建立合适的抽象盒子
- 缩小调试范围
#### 1.1.6.7 单元测试
Java的最佳实践之一: 每个main函数测试库中的所有方法.   
每个main():都可以当作测试用例,复杂了甚至可以独立成模块.
#### 1.1.7.8 外部库
- java.lang.*: Math,Integer,Double,String,StringBuilder
- java.util.Arrays:用的不多
- 书的其他库: 比如BinarySearch
- 开发的Std*库:
### 1.1.7 API
### 1.1.8 字符串
### 1.1.9 输入输出
### 1.1.10 二分查找
### 1.1.11 展望