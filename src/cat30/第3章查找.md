### 3.3.1 2-3树
### 3.3.2 红黑二叉查找树
#### 3.3.2.1 替换3-node
用BST+红黑来表示2-3tree:简称红黑树  
    2-node: 黑链接+标准2-node  
    3-node: 标准2-node + 红链接 + 标准2-node 

#### 3.3.2.2 一种等价的定义
左倾红黑树:
    - 一个node最多只有一条左红链接
    - 树是完全黑色平衡的,可以认为红色链接,不增加深度
#### 3.3.2.3 一一对应
把含红色链接的两个node,当作一个node, 那么左倾红黑树就是完全平衡的. 也可以称为完全黑色平衡二叉树  
#### 3.3.2.4 颜色表示
颜色表示: 父节点指向当前节点的颜色  

#### 3.3.2.5 旋转
一个node只允许有一条左红链接的反例: 一个node有右红或双红  
旋转并修复它: 旋转保证有序性和完美黑平衡    
    rotateLeft: 右红转左红  
    rotateRight: 左红转右红  
    
#### 3.3.2.6 在旋转后重置父节点的链接
root = rotateLeft(root);
#### 3.3.2.7 向单个2-node中插入新键


#### 3.3.2.8 向树底部的2-node插入新键

#### 3.3.2.9 向单个3-node插入新键
3 cases:  
    1. newKey最大.左右红: 两红变两黑  
    2. newKey居中. 右左红: 右红左转变左红, 左2红右转变右红, 左右红变两黑    
    3. newKey最小.左左红: 左2红右转变右红, 左右红变两黑  
   
#### 3.3.2.10 颜色转换
两红转两黑: flipColors();  

#### 3.3.2.11 根节点总是黑色
#### 3.3.2.12 向树底部的3-node插入新键
向3-node插入新键后,旋转至左右红后,颜色变换会使得中结点的链接变红,相当于把它送到父节点.  

#### 3.3.2.13 将红链接在树中向上传递
插入算法分解3-node,将中间键插入父节点,重复直到遇到2-节点或根节点.  
插入的操作对应的旋转和颜色变化:
    - 右子节点红色,而它的左子节点黑色,左转  
    - 左子节点红色,而它的左子节点红色,右转  
    - 左右子节点均为红色,颜色转换  


### 3.3.3 实现
### 3.3.4 删除操作
deleteMin()~deleteMax()和delete()实现  
和插入操作一样,定义一系列局部变换来删除一个节点同时保持树的完美平衡性  

#### 3.3.4.1 自顶向下的2-3-4树
2-3-4树插入算法:查找过程从上到下,将4-node分解为3个2-node  
    目的为了底部只会遇到2-node或3-node,便于插入新键  
用红黑树来实现:
    - 将4-node由三个2-node来表示  
    - 向下过程中分解所有4-结点并进行颜色转换  
    - 在向上的过程中旋转将4-node配平 
    
#### 3.3.4.2 删除最小键
如果兄弟只有一个,直接抢,再抢爹一个.如果不止一个管爹要,爹再管兄弟要.  
这样最后的结点一定是3-node,或4-node,删除掉一个. 回归过程中,再分解4-node,回归左倾红黑树   

#### 3.3.4.3 删除操作
和删除最小键一样,保证查找过程中的结点都是2-node.如果查到键在树的底部,直接删除它.如果不在,把它和它的继承者交换.  
    